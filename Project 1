#include ​<math.h> #include ​<vector> #include ​<stdio.h> #include ​<iostream> #include ​<opencv2/core/core.hpp> #include ​<opencv2/highgui/highgui.hpp> #include ​<opencv2/opencv.hpp> #include ​<opencv2/imgproc/imgproc.hpp> 
 
 
using​ ​namespace​ ​cv​; using​ ​namespace​ ​std​; 
 int​ main(){     ​// (A) i     ​vector​<​Mat​> frames;     ​vector​<​Mat​> images;     ​int​ frame_number = ​485​;     ​for​(​int​ i = ​0​; i<frame_number; i++)     { ​string name = ​format​(​"/Users/jiedai/Desktop/computer     vision/project1/EnterExitCrossingPath/EnterExitCrossingPaths2cor%04d.jpg"​, i);         ​// use %04d to complement i as a 4-digit number         ​Mat​ srcImage = ​imread​(name);         frames.​push_back​(srcImage); 15 
        ​Mat​ grayImage;         ​//convert to grayscale         ​cvtColor​(srcImage, grayImage, ​CV_BGR2GRAY​);         ​if​ ( grayImage.​empty​() )      ​// please, *always check* resource-loading.         {             ​cerr​ << ​"whaa "​ << name << ​" can't be loaded!"​ << ​endl​;             ​continue​;         } 
         images.​push_back​(grayImage);   //        imshow("gray",images[i-2]); //        waitKey(20);     } 
     ​// (A) ii~iii     ​vector​<​Mat​> images_derivative1(images);     ​for​(​int​ i = ​0​; i<frame_number-​2​; i++)     {           images_derivative1[​i​] = ​0.5​ * (images[​i​+​2​] - images[​i​]);​//get the derivative by 0.5*[-1 0 1] 
         ​threshold​(images_derivative1[​i​], images_derivative1[​i​], ​10​, ​255​, ​CV_THRESH_BINARY​);​//set the threshold     } //    imshow("[-1 0 1]derivative",images_derivative1[866]); //    waitKey(1); 
 
  
     ​// (A) iv     ​vector​<​Mat​> images_mask(images_derivative1);     ​for​(​int​ i = ​0​; i<frame_number-​2​; i++)     {         ​bitwise_and​(frames[​i​], frames[​i​], images_mask[​i​], images_derivative1[​i​]);   ​string name = ​format​(​"/Users/jiedai/Desktop/computer vision/project1/Redchair      output/(a)/advbgst_21_%04d.jpg"​, i);         ​vector​<​int​> compression_params;         compression_params.​push_back​(​CV_IMWRITE_JPEG_QUALITY​);         compression_params.​push_back​(​95​);         ​imwrite​(name, images_mask[​i​], compression_params);   //        imshow("mask",images_mask[i]); //        waitKey(20);     } 
 
 
    ​// (B) i 
16 
    ​//add temporal guassian and t-sigma = 0.8     ​vector​<​Mat​> images_temporal_guassian1(images);     ​vector​<​Mat​> images_derivative2(images);     ​Mat​ kernel1 = ​getGaussianKernel​(​3​, ​0.8​);     ​for​(​int​ i = ​0​; i<frame_number-​2​; i++)     { ​Mat temporal_guassian = kernel1.​at​<​double​>(​0​)*images[​i​] + kernel1.​at​<​double​>(​1​)*images[​i​+​1​] +        kernel1.​at​<​double​>(​2​)*images[​i​+​2​];         images_temporal_guassian1.​push_back​(temporal_guassian);     }     ​for​(​int​ i = ​0​; i<frame_number-​4​; i++)     { 
 images_derivative2[​i​] = ​0.5 * (images_temporal_guassian1[​i​+​2​] - images_temporal_guassian1[​i​]);​//get the         derivative by 0.5*[-1 0 1]         ​threshold​(images_derivative2[​i​], images_derivative2[​i​], ​20​, ​255​, ​CV_THRESH_BINARY​);​//set the threshold //        imshow("t-sigma = 1 derivative",images_derivative2[i]); //        waitKey(1);     }     ​vector​<​Mat​> images_mask1(images_derivative2);     ​for​(​int​ i = ​0​; i<frame_number-​2​; i++)     {         ​bitwise_and​(frames[​i​+​2​], frames[​i​+​2​], images_mask1[​i​], images_derivative2[​i​]); 
 ​string name = ​format​(​"/Users/jiedai/Desktop/computer vision/project1/EnterExitCrossingPath      output/(b_temporal1)/EnterExitCrossingPath_%04d.jpg"​, i);         ​vector​<​int​> compression_params;         compression_params.​push_back​(​CV_IMWRITE_JPEG_QUALITY​);         compression_params.​push_back​(​95​);         ​imwrite​(name, images_mask1[​i​], compression_params); 
 //                imshow("mask",images_mask1[i]); //                waitKey(20);     } 
     ​//add temporal guassian and t-sigma = 1.2     ​vector​<​Mat​> images_temporal_guassian2(images);     ​vector​<​Mat​> images_derivative3(images);     ​Mat​ kernel2 = ​getGaussianKernel​(​5​, ​1.2​);     ​for​(​int​ i = ​0​; i<frame_number-​4​; i++)     { ​Mat temporal_guassian = kernel2.​at​<​double​>(​0​)*images[​i​] + kernel2.​at​<​double​>(​1​)*images[​i​+​1​] +        kernel2.​at​<​double​>(​2​)*images[​i​+​2​]         + kernel2.​at​<​double​>(​3​)*images[​i​+​3​] + kernel2.​at​<​double​>(​4​)*images[​i​+​4​];         images_temporal_guassian2.​push_back​(temporal_guassian);     }     ​for​(​int​ i = ​0​; i<frame_number-​6​; i++)     { 17 
images_derivative3[​i​] = ​0.5 * (images_temporal_guassian2[​i​+​2​] - images_temporal_guassian2[​i​]);​//get the         derivative by 0.5*[-1 0 1]         ​threshold​(images_derivative3[​i​], images_derivative3[​i​], ​20​, ​255​, ​CV_THRESH_BINARY​);​//set the threshold //        imshow("t- sigama = 5 derivative",images_derivative3[i]); //        waitKey(1); 
 
    }     ​vector​<​Mat​> images_mask2(images_derivative3);     ​for​(​int​ i = ​0​; i<frame_number-​4​; i++)     {         ​bitwise_and​(frames[​i​+​4​], frames[​i​+​4​], images_mask2[​i​], images_derivative3[​i​]); 
 ​string name = ​format​(​"/Users/jiedai/Desktop/computer vision/project1/EnterExitCrossingPath      output/(b_temporal2)/EnterExitCrossingPath_%04d.jpg"​, i);         ​vector​<​int​> compression_params;         compression_params.​push_back​(​CV_IMWRITE_JPEG_QUALITY​);         compression_params.​push_back​(​95​);         ​imwrite​(name, images_mask2[​i​], compression_params); 
 //                imshow("mask2",images_mask2[i]); //                waitKey(20);     } 
 
 
    ​//add temporal guassian and t-sigma = 1.5     ​vector​<​Mat​> images_temporal_guassian3(images);     ​vector​<​Mat​> images_derivative4(images);     ​Mat​ kernel3 = ​getGaussianKernel​(​9​, ​1.8​);     ​for​(​int​ i = ​0​; i<frame_number-​8​; i++)     { ​Mat temporal_guassian = kernel3.​at​<​double​>(​0​)*images[​i​] + kernel3.​at​<​double​>(​1​)*images[​i​+​1​] +        kernel3.​at​<​double​>(​2​)*images[​i​+​2​] + kernel3.​at​<​double​>(​3​)*images[​i​+​3​] + kernel3.​at​<​double​>(​4​)*images[​i​+​4​] +      kernel3.​at​<​double​>(​5​)*images[​i​+​5​] + kernel3.​at​<​double​>(​6​)*images[​i​+​6​]+ kernel3.​at​<​double​>(​7​)*images[​i​+​7​] +     kernel3.​at​<​double​>(​8​)*images[​i​+​8​];         images_temporal_guassian3.​push_back​(temporal_guassian);     }     ​for​(​int​ i = ​0​; i<frame_number-​10​; i++)     { images_derivative4[​i​] = ​0.5 * (images_temporal_guassian3[​i​+​2​] - images_temporal_guassian3[​i​]);​//get the         derivative by 0.5*[-1 0 1]         ​threshold​(images_derivative4[​i​], images_derivative4[​i​], ​20​, ​255​, ​CV_THRESH_BINARY​);​//set the threshold //        imshow("t- sigama = 10 derivative",images_derivative4[i]); //        waitKey(1); 
 
    }     ​vector​<​Mat​> images_mask3(images_derivative4);     ​for​(​int​ i = ​0​; i<frame_number-​6​; i++) 
18 
    {         ​bitwise_and​(frames[​i​+​6​], frames[​i​+​6​], images_mask3[​i​], images_derivative4[​i​]);   ​string name = ​format​(​"/Users/jiedai/Desktop/computer vision/project1/EnterExitCrossingPath      output/(b_temporal3)/EnterExitCrossingPath_%04d.jpg"​, i);         ​vector​<​int​> compression_params;         compression_params.​push_back​(​CV_IMWRITE_JPEG_QUALITY​);         compression_params.​push_back​(​95​);         ​imwrite​(name, images_mask3[​i​], compression_params);           ​//        imshow("mask3",images_mask3[i]);         ​//        waitKey(20);     } 
     ​// (B) ii     ​vector​<​Mat​> images_spatial_gaussian1(images);     ​vector​<​Mat​> images_derivative5(images_derivative1);     ​for​(​int​ i = ​0​; i<images.​size​(); i++)     { 
         ​GaussianBlur​(images[​i​], images_spatial_gaussian1[​i​],​Size​(​15​,​15​), ​0.0​); 
     }       ​for​(​int​ i = ​0​; i<images.​size​()-​2​; i++)     { 
 images_derivative5[​i​] = ​0.5 * (images_spatial_gaussian1[​i​+​2​] - images_spatial_gaussian1[​i​]);​//get the         derivative by 0.5*[-1 0 1] 
         ​threshold​(images_derivative5[​i​], images_derivative5[​i​], ​20​, ​255​, ​CV_THRESH_BINARY​);​//set the threshold   //        imshow("5*5 gaussianblur",images_derivative5[i]); //        waitKey(1);     }     ​vector​<​Mat​> images_mask2(images_derivative5);     ​for​(​int​ i = ​0​; i<frame_number-​2​; i++)     {         ​bitwise_and​(frames[​i​+​2​], frames[​i​+​2​], images_mask2[​i​], images_derivative5[​i​]); 
 ​string name = ​format​(​"/Users/jiedai/Desktop/computer vision/project1/EnterExitCrossingPath      output/(b_gaussian15*15)/EnterExitCrossingPath_%04d.jpg"​, i);         ​vector​<​int​> compression_params;         compression_params.​push_back​(​CV_IMWRITE_JPEG_QUALITY​);         compression_params.​push_back​(​95​);         ​imwrite​(name, images_mask2[​i​], compression_params);   //        imshow("mask2",images_mask2[i]); 19 
//        waitKey(5);     } 
 
 
    ​vector​<​Mat​> images_spatial_gaussian2(images);     ​vector​<​Mat​> images_derivative6(images);     ​for​(​int​ i = ​0​; i<images.​size​(); i++)     { 
         ​blur​(images[​i​], images_spatial_gaussian2[​i​],​Size​(​5​,​5​)); 
     }     ​for​(​int​ i = ​0​; i<images.​size​()-​2​; i++)     { 
 images_derivative5[​i​] = ​0.5 * (images_spatial_gaussian2[​i​+​2​] - images_spatial_gaussian2[​i​]);​//get the         derivative by 0.5*[-1 0 1] 
         ​threshold​(images_derivative6[​i​], images_derivative6[​i​], ​20​, ​255​, ​CV_THRESH_BINARY​);​//set the threshold //        imshow("box filter",images_derivative6[i]); //        waitKey(1);     } //    vector<Mat> images_mask3(images_derivative6); //    for(int i = 0; i<frame_number-2; i++) //    { //        bitwise_and(frames[i+2], frames[i+2], images_mask3[i], images_derivative6[i]); // // string name = format("/Users/jiedai/Desktop/computer vision/project1/EnterExitCrossingPath      output/(b_box5*5)/EnterExitCrossingPath_%04d.jpg", i); //        vector<int> compression_params; //        compression_params.push_back(CV_IMWRITE_JPEG_QUALITY); //        compression_params.push_back(95); //        imwrite(name, images_mask3[i], compression_params);           ​//        imshow("mask",images_mask3[i]);         ​//        waitKey(50); //    } 
 
 
//    vector<Mat> images_spatial_gaussian3(images); //    vector<Mat> images_derivative7(images); //    for(int i = 0; i<images.size(); i++) //    { // //        GaussianBlur(images[i], images_spatial_gaussian3[i],Size(3,3), 5.0); // //    } //    for(int i = 0; i<images.size()-2; i++) 
20 
//    { // // images_derivative7[i] = 0.5 * (images_spatial_gaussian3[i+2] - images_spatial_gaussian3[i]);//get the         derivative by 0.5*[-1 0 1] // //        threshold(images_derivative7[i], images_derivative7[i], 20, 255, CV_THRESH_BINARY);//set the threshold ////        imshow("3*3 gaussianblur s-sigma=3",images_derivative7[i]); ////        waitKey(1); //    } // //    vector<Mat> images_spatial_gaussian4(images); //    vector<Mat> images_derivative8(images); //    for(int i = 0; i<images.size(); i++) //    { //        GaussianBlur(images[i], images_spatial_gaussian4[i],Size(3,3), 5.0); //    } //    for(int i = 0; i<images.size()-2; i++) //    { // // images_derivative8[i] = 0.5 * (images_spatial_gaussian4[i+2] - images_spatial_gaussian4[i]);//get the         derivative by 0.5*[-1 0 1] //        threshold(images_derivative8[i], images_derivative8[i], 15, 255, CV_THRESH_BINARY);//set the threshold ////        imshow("3*3 gaussianblur s-sigma=5",images_derivative8[i]); ////        waitKey(1); //    } //       ​// (B) iii     ​vector​<​Mat​> images_derivative9(images_derivative1);     ​for​(​int​ i = ​0​; i<frame_number-​2​; i++)     {         ​float​ est_mean=​0​;         ​float​ est_sigma=​0​;         ​int​ est_num=​0​;         ​for​(​int​ m=​0​;m<images[​i​].​rows​;m++)         {             ​for​(​int​ n=​0​;n<images[​i​].​cols​;n++)             {                 ​if​(images_derivative9[​i​].​at​<​uchar​>(m, n) <​8​)                 {                     est_num++;                     est_mean += images_derivative9[​i​].​at​<​uchar​>(m, n);                 }             }         }         est_mean = est_mean/est_num; //        cout <<"No."<< i<<" est_num = " << est_num  <<endl; //        cout <<"No."<< i<<" est_mean = " << est_mean  <<endl; 21 
        ​for​(​int​ m=​0​;m<images[​i​].​rows​;m++)         {             ​for​(​int​ n=​0​;n<images[​i​].​cols​;n++)             {                 ​if​(images_derivative9[​i​].​at​<​uchar​>(m, n) <​8​)                 {                     est_sigma += ​pow​(images_derivative9[​i​].​at​<​uchar​>(m, n) - est_mean,​2​);                 }             }         }         est_sigma = ​sqrt​(est_sigma)/(est_num-​1​); //        cout <<"No."<< i<<" est_sigma = " << est_sigma  <<endl;           ​threshold​(images_derivative9[​i​], images_derivative9[​i​],​50​ , ​255​, ​CV_THRESH_BINARY​);​//set the threshold //        imshow("dynamic threshold",images_derivative9[i]); //        waitKey(1);     } 
     ​return​ ​0​; } 
